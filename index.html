<!DOCTYPE html>
<html lang="en">

<head>
	<title>three.js webaudio - visualizer</title>
	<meta charset="utf-8">
	<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
	<link type="text/css" rel="stylesheet" href="main.css">

	<script id="vertexShader" type="x-shader/x-vertex">
		varying vec2 vUv;
		void main() {
			vUv = uv;
			gl_Position = vec4( position, 1.0 );
		}
	</script>

	<script id="fragmentShader" type="x-shader/x-fragment">
		uniform sampler2D tAudioData;
		varying vec2 vUv;
		void main() {
			vec3 backgroundColor = vec3( 0.125, 0.125, 0.125 );
			vec3 color = vec3( 1.0, 1.0, 0.0 );
			float f = texture2D( tAudioData, vec2( vUv.x, 0.0 ) ).r;
			float i = step( vUv.y, f ) * step( f - 0.0125, vUv.y );
			gl_FragColor = vec4( mix( backgroundColor, color, i ), 1.0 );
		}
	</script>

</head>

<body>
	<div id="overlay">
		<button id="startButton">Play</button>
	</div>
	<div id="container"></div>
	<div id="info">
		sankarsh
	</div>

	<script async src="https://unpkg.com/es-module-shims@1.3.6/dist/es-module-shims.js"></script>
	<script type="importmap">
		{
			"imports": {
				"three": "https://unpkg.com/three@0.150.1/build/three.module.js",
				"three/addons/": "https://unpkg.com/three/examples/jsm/"
			}
		}
	</script>

	<script type="module">
		import * as THREE from 'three';
		import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

		const fftSize = 2048;

		let scene, camera, renderer, analyser, uniforms;
		let mediaElement;
		let lines = [];
		let pointsRight = [];
		let pointsLeft = [];
		let zCoord = 1000;
		let controls = null;

		const startButton = document.getElementById('startButton');
		startButton.addEventListener('click', init);

		function init() {
			const overlay = document.getElementById('overlay');
			overlay.remove();

			const container = document.getElementById('container');

			renderer = new THREE.WebGLRenderer({ antialias: true });
			renderer.setClearColor(0x000000);
			renderer.setPixelRatio(window.devicePixelRatio);
			container.appendChild(renderer.domElement);

			scene = new THREE.Scene();

			camera = new THREE.PerspectiveCamera(20, window.innerWidth / window.innerHeight, 1, 1000);
			camera.position.z = zCoord + 5
			controls = new OrbitControls(camera, renderer.domElement)

			const listener = new THREE.AudioListener();

			const audio = new THREE.Audio(listener);
			const file = './sounds/sound.mp3';

			mediaElement = new Audio(file);
			mediaElement.currentTime = 0;
			mediaElement.play();
			audio.setMediaElementSource(mediaElement);

			analyser = new THREE.AudioAnalyser(audio, fftSize);

			let numLines = 10;

			for (let i = 0; i < numLines; i++) {
				pointsRight = []
				const geometryRight = new THREE.BufferGeometry().setFromPoints(pointsRight);
				const materialRight = new THREE.LineBasicMaterial({ color: 0x00ff00 });
				const lineMeshRight = new THREE.Line(geometryRight, materialRight);
				scene.add(lineMeshRight);

				pointsLeft = []
				const geometryLeft = new THREE.BufferGeometry().setFromPoints(pointsLeft);
				const materialLeft = new THREE.LineBasicMaterial({ color: 0x00ff00 });
				const lineMeshLeft = new THREE.Line(geometryLeft, materialLeft);
				scene.add(lineMeshLeft);

				lines.push([lineMeshRight, lineMeshLeft])
			}

			window.addEventListener('resize', onWindowResize);
			onWindowResize();

			animate();
		}

		const onWindowResize = () => renderer.setSize(window.innerWidth * 0.92, window.innerHeight * 0.92);

		function animate() {
			requestAnimationFrame(animate);
			controls.update();
			console.log(camera.position)
			render();
		}

		function render() {
			// Remove first line
			// scene.remove(lines[0][0])
			// scene.remove(lines[0][1])
			// lines.shift()

			zCoord -= 0.1
			camera.position.z -= 0.1
			camera.lookAt(scene.position);
			controls.update();

			analyser.getFrequencyData();
			pointsRight = []
			let rotate = 0;
			for (let i = 1; i < analyser.data.length + rotate; i++) {
				let reverseI = (fftSize / 2) - i;
				let theta = reverseI / (fftSize / 2) * Math.PI * 0.5;

				let realI = i - rotate;
				let multiplier = 0.5;
				if (realI >= 0 && realI < analyser.data.length - (rotate * 2))
					multiplier = ((analyser.data[realI] / 255) + 1) * 0.5
				else if (realI >= analyser.data.length - (rotate)) continue;
				let x = Math.cos(theta);
				let y = Math.sin(theta) * 2 - 1;
				x *= multiplier;
				y *= multiplier;
				pointsRight.push(new THREE.Vector3(x, y, zCoord));
			}
			pointsRight.push(new THREE.Vector3(0.5, -1, zCoord));
			const geometryRight = new THREE.BufferGeometry().setFromPoints(pointsRight);
			const materialRight = new THREE.LineBasicMaterial({ color: 0x00ff00 });
			const lineMeshRight = new THREE.Line(geometryRight, materialRight);
			scene.add(lineMeshRight);

			pointsLeft = []
			// pointsLeft.push(new THREE.Vector3(0 + (1 / (fftSize / 3)), (Math.sin(Math.PI / 2) * 2 - 1) * ((analyser.data[rotate] / 255) + 1) * 0.5, zCoord));
			// pointsLeft.push(new THREE.Vector3(0, (Math.sin(Math.PI / 2) * 2 - 1) * ((analyser.data[rotate] / 255) + 1) * 0.5, zCoord));
			for (let i = 1; i < analyser.data.length + rotate; i++) {
				let reverseI = i;
				let theta = (reverseI / (fftSize / 2) * Math.PI * 0.5) + Math.PI / 2

				let realI = i - rotate;
				let multiplier = 0.5;
				if (realI >= 0 && realI < analyser.data.length - (rotate * 2))
					multiplier = ((analyser.data[realI] / 255) + 1) * 0.5
				else if (realI >= analyser.data.length - (rotate)) continue;
				let x = Math.cos(theta);
				let y = Math.sin(theta) * 2 - 1;
				x *= multiplier;
				y *= multiplier;
				pointsLeft.push(new THREE.Vector3(x, y, zCoord));
			}
			pointsLeft.push(new THREE.Vector3(-0.5, -1, zCoord));
			const geometryLeft = new THREE.BufferGeometry().setFromPoints(pointsLeft);
			const materialLeft = new THREE.LineBasicMaterial({ color: 0x00ff00 });
			const lineMeshLeft = new THREE.Line(geometryLeft, materialLeft);
			scene.add(lineMeshLeft);

			lines.push([lineMeshRight, lineMeshLeft])
			renderer.render(scene, camera);
		}

	</script>

</body>

</html>